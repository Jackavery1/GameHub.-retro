const express = require("express");
const http = require("http");
const WebSocket = require("ws");

// Charger les variables d'environnement
require("dotenv").config();

// Import de la configuration de base de donn√©es
const dbConfig = require("../config/db");

// Import des outils MCP
const userTools = require("./tools/userTools");
const gameTools = require("./tools/gameTools");
const tournamentTools = require("./tools/tournamentTools");
const authTools = require("./tools/authTools");
const databaseTools = require("./tools/databaseTools");
const intelligenceTools = require("./tools/intelligenceTools");

// Import du middleware d'authentification
const MCPAuthMiddleware = require("./middleware/auth");

class MCPServer {
  constructor() {
    this.app = express();
    this.server = http.createServer(this.app);
    this.wss = new WebSocket.Server({ server: this.server });
    this.tools = new Map();
    this.clients = new Map(); // Map des clients authentifi√©s
    this.isTestMode =
      process.env.NODE_ENV === "test" || !process.env.MONGODB_URI;
    this.authMiddleware = new MCPAuthMiddleware();

    // Initialiser la connexion √† la base de donn√©es
    this.initializeDatabase();
  }

  async initializeDatabase() {
    try {
      // Se connecter √† la base de donn√©es
      await dbConfig.connectDB();
      console.log("‚úÖ Base de donn√©es connect√©e pour le serveur MCP");

      // Configurer le serveur apr√®s la connexion DB
      this.setupMiddleware();
      this.setupWebSocket();
      this.registerTools();
      this.setupMaintenanceTasks();
    } catch (error) {
      console.error("‚ùå Erreur de connexion √† la base de donn√©es:", error);
      // Continuer en mode test si la DB n'est pas disponible
      this.isTestMode = true;
      console.log("üîÑ Mode test activ√© - base de donn√©es non disponible");

      this.setupMiddleware();
      this.setupWebSocket();
      this.registerTools();
      this.setupMaintenanceTasks();
    }
  }

  setupMiddleware() {
    // Middleware CORS global pour tous les endpoints
    this.app.use((req, res, next) => {
      res.header("Access-Control-Allow-Origin", "http://localhost:3001");
      res.header(
        "Access-Control-Allow-Methods",
        "GET, POST, PUT, DELETE, OPTIONS"
      );
      res.header(
        "Access-Control-Allow-Headers",
        "Content-Type, Authorization, X-Requested-With"
      );
      res.header("Access-Control-Allow-Credentials", "true");

      // Gestion de la requ√™te preflight OPTIONS
      if (req.method === "OPTIONS") {
        res.sendStatus(200);
        return;
      }

      next();
    });

    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));

    // Endpoint public pour la sant√© (sans authentification)
    this.app.get("/health", (req, res) => {
      res.json({
        status: "healthy",
        server: "gamehub-retro-mcp",
        version: "1.0.0",
        mode: this.isTestMode ? "test" : "production",
        secured: true,
        message: "Acc√®s MCP r√©serv√© aux administrateurs",
        database: this.isTestMode ? "Mode test" : "Connect√©e",
        timestamp: new Date().toISOString(),
      });
    });

    // Endpoint de test simple pour d√©boguer
    this.app.get("/test", (req, res) => {
      res.json({
        message: "Serveur MCP op√©rationnel",
        cookies: req.headers.cookie || "Aucun cookie",
        userAgent: req.headers["user-agent"],
        timestamp: new Date().toISOString(),
      });
    });

    // Endpoints prot√©g√©s n√©cessitant une authentification admin
    this.app.get(
      "/tools",
      this.authMiddleware.authenticateAdmin.bind(this.authMiddleware),
      (req, res) => {
        const toolsList = Array.from(this.tools.entries()).map(
          ([name, tool]) => ({
            name,
            description: tool.description,
            inputSchema: tool.inputSchema,
          })
        );
        res.json({
          tools: toolsList,
          authenticatedAs: req.adminUser.name,
          role: req.adminUser.role,
        });
      }
    );

    // Endpoint pour g√©n√©rer un token d'acc√®s admin
    this.app.post("/auth/generate-token", async (req, res) => {
      try {
        console.log("üîê Tentative de g√©n√©ration de token MCP:", req.body);

        const { sessionBased, adminUserId, adminPassword } = req.body;

        let adminUser = null;

        if (sessionBased) {
          console.log("üîë Authentification par session demand√©e");

          // Authentification par session - v√©rifier les cookies de session
          const sessionId =
            req.headers.cookie?.match(/connect\.sid=([^;]+)/)?.[1];

          console.log(
            "üç™ Session ID extrait:",
            sessionId ? "Pr√©sent" : "Absent"
          );

          if (!sessionId) {
            console.log("‚ùå Aucune session d√©tect√©e");
            return res.status(401).json({
              error: "Session invalide",
              message: "Aucune session active d√©tect√©e",
            });
          }

          // V√©rifier la session via le serveur principal
          try {
            console.log(
              "üîç V√©rification de session via le serveur principal..."
            );

            const sessionCheck = await fetch(
              `http://localhost:3001/auth/check-session`,
              {
                method: "GET",
                headers: {
                  Cookie: `connect.sid=${sessionId}`,
                },
              }
            );

            console.log(
              "üì° R√©ponse du serveur principal:",
              sessionCheck.status
            );

            if (!sessionCheck.ok) {
              console.log("‚ùå Session invalide c√¥t√© serveur principal");
              return res.status(401).json({
                error: "Session expir√©e",
                message: "Veuillez vous reconnecter",
              });
            }

            const sessionData = await sessionCheck.json();
            console.log("üìä Donn√©es de session:", sessionData);

            if (sessionData.role !== "admin") {
              console.log("‚ùå Utilisateur non admin:", sessionData.role);
              return res.status(403).json({
                error: "Acc√®s refus√©",
                message: "Droits administrateur requis",
              });
            }

            adminUser = {
              id: sessionData.userId,
              name: sessionData.username,
              role: sessionData.role,
            };

            console.log("‚úÖ Utilisateur admin identifi√©:", adminUser.name);
          } catch (sessionError) {
            console.error(
              "‚ùå Erreur lors de la v√©rification de session:",
              sessionError
            );
            return res.status(500).json({
              error: "Erreur de v√©rification de session",
              message:
                "Impossible de v√©rifier la session: " + sessionError.message,
            });
          }
        } else {
          console.log("üîë Authentification par identifiants demand√©e");

          // Authentification traditionnelle par identifiants
          if (!adminUserId || !adminPassword) {
            return res.status(400).json({
              error: "Identifiants requis",
              message: "adminUserId et adminPassword sont n√©cessaires",
            });
          }

          // V√©rifier que l'utilisateur est admin et que le mot de passe est correct
          const User = require("../models/User");
          const admin = await User.findById(adminUserId);

          if (!admin || admin.role !== "admin") {
            return res.status(403).json({
              error: "Acc√®s refus√©",
              message: "Utilisateur non admin",
            });
          }

          if (!admin.verifyPassword(adminPassword)) {
            return res.status(401).json({
              error: "Mot de passe incorrect",
              message: "Authentification √©chou√©e",
            });
          }

          adminUser = { id: admin._id, name: admin.username, role: admin.role };
        }

        // G√©n√©rer le token MCP
        console.log("üé´ G√©n√©ration du token MCP pour:", adminUser.name);
        const token = await this.authMiddleware.generateAdminToken(
          adminUser.id
        );

        console.log("‚úÖ Token MCP g√©n√©r√© avec succ√®s");

        res.json({
          success: true,
          token,
          expiresAt: new Date(Date.now() + this.authMiddleware.tokenExpiry),
          message: "Token MCP g√©n√©r√© avec succ√®s",
          user: {
            id: adminUser.id,
            name: adminUser.name,
            role: adminUser.role,
          },
        });
      } catch (error) {
        console.error("‚ùå Erreur lors de la g√©n√©ration du token:", error);
        res.status(500).json({
          error: "Erreur interne",
          message: error.message,
          stack:
            process.env.NODE_ENV === "development" ? error.stack : undefined,
        });
      }
    });

    // Endpoint pour r√©voquer un token
    this.app.delete(
      "/auth/revoke-token",
      this.authMiddleware.authenticateAdmin.bind(this.authMiddleware),
      async (req, res) => {
        try {
          const { token } = req.body;

          if (!token) {
            return res.status(400).json({
              error: "Token requis",
              message: "Le token √† r√©voquer est n√©cessaire",
            });
          }

          const success = await this.authMiddleware.revokeAdminToken(token);

          if (success) {
            res.json({
              success: true,
              message: "Token r√©voqu√© avec succ√®s",
            });
          } else {
            res.status(500).json({
              error: "Erreur lors de la r√©vocation",
              message: "Impossible de r√©voquer le token",
            });
          }
        } catch (error) {
          console.error("Erreur lors de la r√©vocation du token:", error);
          res.status(500).json({
            error: "Erreur interne",
            message: error.message,
          });
        }
      }
    );

    // Endpoint pour les statistiques admin
    this.app.get(
      "/admin/stats",
      this.authMiddleware.authenticateAdmin.bind(this.authMiddleware),
      async (req, res) => {
        try {
          const stats = {
            connectedClients: this.clients.size,
            activeTools: this.tools.size,
            serverUptime: process.uptime(),
            memoryUsage: process.memoryUsage(),
            authenticatedAs: req.adminUser.name,
            timestamp: new Date(),
          };

          res.json(stats);
        } catch (error) {
          console.error("Erreur lors de la r√©cup√©ration des stats:", error);
          res.status(500).json({
            error: "Erreur interne",
            message: error.message,
          });
        }
      }
    );

    // Endpoint pour les t√¢ches de maintenance
    this.app.post("/tools/:taskName", async (req, res) => {
      try {
        const { taskName } = req.params;
        const { dryRun = true, ...params } = req.body;

        // Simuler l'ex√©cution des t√¢ches de maintenance
        const taskResults = {
          "health-check": {
            status: "success",
            message: "V√©rification de sant√© effectu√©e",
            details: {
              database: "OK",
              memory: "OK",
              cpu: "OK",
              uptime: process.uptime(),
            },
          },
          "database-optimization": {
            status: "success",
            message: "Optimisation de base de donn√©es effectu√©e",
            details: {
              indexes: "Optimis√©s",
              queries: "Analys√©es",
              performance: "Am√©lior√©e",
            },
          },
          "user-cleanup": {
            status: "success",
            message: "Nettoyage des utilisateurs effectu√©",
            details: {
              inactiveUsers: "Identifi√©s",
              cleanupMode: dryRun ? "Simulation" : "Ex√©cution",
            },
          },
          "database-backup": {
            status: "success",
            message: "Sauvegarde de base de donn√©es effectu√©e",
            details: {
              backupSize: "2.5 MB",
              backupTime: new Date().toISOString(),
              location: "/backups/",
            },
          },
        };

        const result = taskResults[taskName] || {
          status: "error",
          message: `T√¢che '${taskName}' non reconnue`,
        };

        res.json(result);
      } catch (error) {
        console.error(
          `Erreur lors de l'ex√©cution de la t√¢che ${req.params.taskName}:`,
          error
        );
        res.status(500).json({
          status: "error",
          message: "Erreur lors de l'ex√©cution de la t√¢che",
          error: error.message,
        });
      }
    });
  }

  setupWebSocket() {
    this.wss.on("connection", async (ws, req) => {
      console.log("üîå Nouvelle connexion WebSocket MCP");

      // Authentification WebSocket
      const token =
        req.url.split("token=")[1] ||
        req.headers["authorization"]?.replace("Bearer ", "");

      if (!token) {
        ws.send(
          JSON.stringify({
            type: "error",
            error: "Authentification requise",
            details: "Token d'acc√®s MCP requis pour la connexion",
          })
        );
        ws.close(1008, "Token d'authentification manquant");
        return;
      }

      const authResult = await this.authMiddleware.authenticateWebSocket(
        ws,
        token
      );

      if (!authResult.isValid) {
        ws.send(
          JSON.stringify({
            type: "error",
            error: "Acc√®s refus√©",
            details: authResult.error,
          })
        );
        ws.close(1008, "Authentification √©chou√©e");
        return;
      }

      // Connexion authentifi√©e r√©ussie
      console.log(
        `üîê Client MCP authentifi√©: ${authResult.user.name} (${authResult.user.role})`
      );
      this.clients.set(ws, authResult.user);

      ws.on("message", async (message) => {
        try {
          const data = JSON.parse(message);
          await this.handleMessage(ws, data);
        } catch (error) {
          console.error("‚ùå Erreur lors du traitement du message:", error);
          this.sendError(ws, "Erreur de traitement", error.message);
        }
      });

      ws.on("close", () => {
        console.log(
          `üîå Client MCP d√©connect√©: ${this.clients.get(ws)?.name || "Inconnu"}`
        );
        this.clients.delete(ws);
      });

      ws.on("error", (error) => {
        console.error("‚ùå Erreur WebSocket:", error);
        this.clients.delete(ws);
      });

      this.sendMessage(ws, {
        type: "welcome",
        message: "Bienvenue sur le serveur MCP GameHub Retro!",
        server: "gamehub-retro-mcp",
        version: "1.0.0",
        mode: this.isTestMode ? "test" : "production",
        secured: true,
        authenticatedAs: authResult.user.name,
        role: authResult.user.role,
        availableTools: Array.from(this.tools.keys()),
      });
    });
  }

  registerTools() {
    const allTools = [
      ...userTools,
      ...gameTools,
      ...tournamentTools,
      ...authTools,
      ...databaseTools,
      ...intelligenceTools,
    ];

    allTools.forEach((tool) => {
      this.tools.set(tool.name, tool);
      console.log(`üõ†Ô∏è  Outil enregistr√©: ${tool.name}`);
    });

    console.log(`‚úÖ ${this.tools.size} outils MCP enregistr√©s`);
  }

  async handleMessage(ws, data) {
    const { type, tool, params, requestId } = data;

    switch (type) {
      case "tool_call":
        await this.handleToolCall(ws, tool, params, requestId);
        break;

      case "ping":
        this.sendMessage(ws, { type: "pong", timestamp: Date.now() });
        break;

      default:
        this.sendError(
          ws,
          "Type de message non support√©",
          `Type '${type}' non reconnu`
        );
    }
  }

  async handleToolCall(ws, toolName, params, requestId) {
    const tool = this.tools.get(toolName);
    const adminUser = this.clients.get(ws);

    if (!tool) {
      this.sendError(
        ws,
        "Outil non trouv√©",
        `L'outil '${toolName}' n'existe pas`,
        requestId
      );
      return;
    }

    try {
      console.log(
        `üõ†Ô∏è  Appel d'outil: ${toolName} par ${adminUser.name}`,
        params
      );

      let result;
      if (this.isTestMode && toolName.startsWith("get_database_")) {
        result = {
          message: "Mode test - simulation de la base de donn√©es",
          tool: toolName,
          simulated: true,
        };
      } else {
        result = await tool.handler(params);
      }

      this.sendMessage(ws, {
        type: "tool_result",
        tool: toolName,
        result,
        requestId,
        timestamp: Date.now(),
        executedBy: adminUser.name,
      });

      console.log(`‚úÖ R√©sultat de ${toolName}:`, result);
    } catch (error) {
      console.error(`‚ùå Erreur dans l'outil ${toolName}:`, error);
      this.sendError(ws, "Erreur d'ex√©cution", error.message, requestId);
    }
  }

  sendMessage(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  }

  sendError(ws, error, details, requestId = null) {
    const errorMessage = {
      type: "error",
      error,
      details,
      timestamp: Date.now(),
    };

    if (requestId) {
      errorMessage.requestId = requestId;
    }

    this.sendMessage(ws, errorMessage);
  }

  broadcast(message) {
    this.clients.forEach((adminUser, client) => {
      if (client.readyState === WebSocket.OPEN) {
        this.sendMessage(client, message);
      }
    });
  }

  // Configuration des t√¢ches de maintenance automatique
  setupMaintenanceTasks() {
    // Nettoyer les tokens expir√©s toutes les heures
    setInterval(() => {
      this.authMiddleware.cleanupExpiredTokens();
      console.log("üßπ Nettoyage des tokens expir√©s effectu√©");
    }, 60 * 60 * 1000);

    // Nettoyer les clients d√©connect√©s toutes les 5 minutes
    setInterval(() => {
      for (const [ws, adminUser] of this.clients.entries()) {
        if (ws.readyState !== WebSocket.OPEN) {
          this.clients.delete(ws);
          console.log(`üßπ Client d√©connect√© supprim√©: ${adminUser.name}`);
        }
      }
    }, 5 * 60 * 1000);

    console.log("üîÑ T√¢ches de maintenance automatique configur√©es");
  }

  start(port = 3002) {
    this.server.listen(port, () => {
      console.log(`üöÄ Serveur MCP GameHub Retro d√©marr√© sur le port ${port}`);
      console.log(`üì° WebSocket: ws://localhost:${port}?token=YOUR_TOKEN`);
      console.log(`üåê HTTP: http://localhost:${port}`);
      console.log(`üîç Sant√©: http://localhost:${port}/health`);
      console.log(`üõ†Ô∏è  Outils: http://localhost:${port}/tools (Admin Only)`);
      console.log(`üîê Auth: http://localhost:${port}/auth/generate-token`);
      console.log(
        `üìä Stats: http://localhost:${port}/admin/stats (Admin Only)`
      );
      console.log(`üîß Mode: ${this.isTestMode ? "TEST" : "PRODUCTION"}`);
      console.log(`üõ°Ô∏è  S√©curit√©: Acc√®s MCP r√©serv√© aux administrateurs`);
    });
  }

  stop() {
    this.wss.close();
    this.server.close();
    console.log("üõë Serveur MCP arr√™t√©");
  }
}

// D√©marrage du serveur
async function main() {
  try {
    console.log("üöÄ D√©marrage du serveur MCP GameHub Retro s√©curis√©...");

    const mcpServer = new MCPServer();

    // Attendre l'initialisation de la base de donn√©es
    await mcpServer.initializeDatabase();

    // D√©marrer le serveur
    mcpServer.start();

    // Gestion de l'arr√™t propre
    process.on("SIGINT", () => {
      console.log("\nüõë Arr√™t du serveur MCP...");
      mcpServer.stop();
      process.exit(0);
    });

    process.on("SIGTERM", () => {
      console.log("\nüõë Arr√™t du serveur MCP...");
      mcpServer.stop();
      process.exit(0);
    });
  } catch (error) {
    console.error("‚ùå Erreur lors du d√©marrage:", error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = MCPServer;
